use ethers::abi::Abi;
use std::str::FromStr;
use zksync_web3_rs::prelude::abigen;
use zksync_web3_rs::providers::{Middleware, Provider};
use zksync_web3_rs::signers::{LocalWallet, Signer};
use zksync_web3_rs::zks_wallet::DeployRequest;
use zksync_web3_rs::ZKSWallet;

// This is the default url for a local `era-test-node` instance.
static ERA_PROVIDER_URL: &str = "http://127.0.0.1:8011";

// This is the private key for one of the rich wallets that come bundled with the era-test-node.
static PRIVATE_KEY: &str = "7726827caac94a7f9e1b160f7ea819f172f7b6f9d2a97f992c38edeab82d4110";

static CONTRACT_BIN: &str = include_str!("./Greeter.bin");
static CONTRACT_ABI: &str = include_str!("./Greeter.abi");

// Use `ethers` to
abigen!(Greeter, "./examples/contract-deployment/Greeter.abi");

#[tokio::main(flavor = "current_thread")]
async fn main() {
    // Note that for this code example we only need to interface with zkSync Era. We don't care
    // about the Ethereum layer-1 network.
    let zk_wallet = {
        let era_provider = Provider::try_from(ERA_PROVIDER_URL).unwrap();
        let chain_id = era_provider.get_chainid().await.unwrap();
        let l2_wallet = LocalWallet::from_str(PRIVATE_KEY)
            .unwrap()
            .with_chain_id(chain_id.as_u64());
        ZKSWallet::new(l2_wallet, None, Some(era_provider), None).unwrap()
    };

    // Deploy contract:
    let contract_address = {
        let abi = Abi::load(CONTRACT_ABI.as_bytes()).unwrap();
        let contract_bin = hex::decode(CONTRACT_BIN).unwrap().to_vec();
        let request = DeployRequest::with(abi, contract_bin, vec!["Hey".to_owned()])
            .from(zk_wallet.l2_address());
        let address = zk_wallet.deploy(&request).await.unwrap();

        println!("Contract address: {:#?}", address);

        address
    };

    // Now that the contract is deployed to zkSync Era, we can create a `Greeter` instance the same
    // way we would do in a regular `ethers` project. The great thing about zkSync is that allows
    // a transparent interface for both layer one and layer two.
    //
    // The `Greeter` struct, generated by the `abigen!` macro, provides us a high-level abstraction
    // that allows us to interact with the deployed contract and sign method calls.
    let greeter = Greeter::new(contract_address, zk_wallet.get_era_provider().unwrap());

    // Call the greet view method:
    {
        let greet = greeter.greet().call().await.unwrap();
        println!("greet() response: {:#?}", greet);
    }
}
